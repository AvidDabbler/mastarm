#!/usr/bin/env node

const checkDependencies = require('check-dependencies')
const commander = require('commander')
const path = require('path')

const loadConfig = require('../lib/load-config')
const pkg = require('../lib/pkg')

commander
  .version(require('../package.json').version)
  .usage('<cmd> [options]')
  .option('-c, --config <path>', 'Path to configuration files.', path.join(process.cwd(), '/configurations/default'))
  .option('-e, --env <environment>', 'Environment to use.', process.env.NODE_ENV || 'development')
  .option('-m, --minify', 'Minify built files.')
  .option('-S, --skip-check-dependencies', 'Skip checking and installing out of date package.json dependencies.')

commander
  .command('build [entries...]')
  .description('Bundle JavaScript & CSS')
  .option('-F, --flyle', 'Cache and serve tiles.')
  .option('-p, --proxy <address>', 'Proxy calls through to target address.')
  .option('-s, --serve', 'Serve with budo. Auto-matically rebuilds on changes.')
  .option('-w, --watch', 'Rebuild on changes with watchify.')
  .action(function (entries, options) {
    const config = loadConfig(process.cwd(), commander.config, commander.env)
    const get = (item) => val([options, commander, config.settings], item)
    const files = parseEntries(entries, get)

    if (get('serve')) {
      const budo = require('../lib/budo')
      files.map(budo({
        config,
        flyle: get('flyle'),
        proxy: get('proxy')
      }))
    } else {
      const build = require('../lib/build')
      files.map(build({
        config,
        env: get('env'),
        minify: get('minify'),
        watch: get('watch')
      }))
    }
  })

commander
  .command('commit')
  .description('Force intelligent commit messages.')
  .action(function () {
    popMastarmFromArgv()

    const path = require('path')
    const bootstrap = require('commitizen/dist/cli/git-cz').bootstrap

    bootstrap({
      cliPath: path.join(__dirname, '../node_modules/commitizen'),
      config: {
        path: 'cz-conventional-changelog'
      }
    })
  })

commander
  .command('deploy [entries...]')
  .usage('[entries...] [options]')
  .description('Bundle & Deploy JavaScript & CSS')
  .option('--cloudfront', 'CloudFront Distribution ID to invalidate.')
  .option('--s3bucket', 'S3 Bucket to push to.')
  .action(function (entries, options) {
    const pushToS3 = require('../lib/push-to-s3')

    const config = loadConfig(process.cwd(), commander.config, commander.env)
    const get = (item) => val([options, commander, config.settings], item)
    const files = parseEntries(entries, get)

    files.map(pushToS3({
      cloudfront: get('cloudfront'),
      config,
      env: get('env'),
      minify: get('minify'),
      s3bucket: get('s3bucket')
    }))
  })

commander
  .command('lint [paths...]')
  .description('Lint JavaScript [& CSS coming soon!]')
  .action(function () {
    const engine = require('standard-engine')
    const standard = require('standard')

    // get lint out of there
    process.argv.pop()
    // Force verbose
    process.argv.push('--verbose')

    engine.cli(Object.assign({}, standard, {
      cwd: process.cwd(),
      homepage: 'https://github.com/conveyal/mastarm'
    }))
  })

commander.parse(process.argv)

if (!commander.skipCheckDependencies) {
  const results = checkDependencies.sync({
    install: true,
    packageDir: process.cwd()
  })
  if (results.status !== 0) {
    console.error(results.error)
    process.exit(results.status)
  } else if (!results.depsWereOk) {
    console.log('Updated out of date dependencies found in package.json. Please try running the command again.')
    process.exit(results.status)
  }
}

function parseEntries (entries, get) {
  const files = entries.map((entry) => {
    entry = entry.split(':')
    if (entry.length === 1) {
      entry.push(`assets/${entry[0]}`)
    }
    return entry
  })

  if (files.length === 0) {
    files.push([
      get('entry') || pkg.main || 'index.js',
      get('outfile') || 'assets/index.js'
    ])
  }

  return files
}

/**
 * A lot of subcommands utilize exact argument lengths. Pop mastarm to handle it.
 */
function popMastarmFromArgv () {
  process.argv = process.argv.slice(0, 1).concat(process.argv.slice(2))
}

function val (targets, i) {
  const ts = targets.filter((t) => t[i] !== undefined)
  if (ts.length > 0) return ts[0][i]
}
