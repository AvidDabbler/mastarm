#!/usr/bin/env node

const commander = require('commander')
const fs = require('fs')
const path = require('path')

const loadConfig = require('../lib/load-config')
const logger = require('../lib/logger')
const util = require('../lib/util')

commander
  .version(require('../package.json').version)
  .option('-c, --config <path>', 'Path to configuration files.', path.join(process.cwd(), '/configurations/default'))
  .option('-e, --env <environment>', 'Environment to use.')
  .option('-m, --minify', 'Minify built files.')
  .option('-O, --outdir <dir>', 'Publish directory', '')

commander
  .command('build [entries...]')
  .description('Bundle JavaScript & CSS')
  .option('-F, --flyle', 'Cache and serve tiles.')
  .option('-p, --proxy <address>', 'Proxy calls through to target address.')
  .option('-s, --serve', 'Serve with budo. Auto-matically rebuilds on changes.')
  .option('-w, --watch', 'Automatically rebuild on changes.')
  .action(function (entries, options) {
    const config = loadConfig(process.cwd(), commander.config, commander.env)
    const get = util.makeGetFn([options, commander, config.settings])
    const files = util.parseEntries([...entries, ...(get('entries') || [])], get('outdir'))
    util.assertEntriesExist(files)
    const watch = get('watch')
    const opts = {
      config,
      env: get('env'),
      files,
      flyle: get('flyle'),
      minify: get('minify'),
      proxy: get('proxy'),
      watch
    }
    if (get('serve')) {
      const budo = require('../lib/budo')
      budo(opts)
    } else {
      const build = require('../lib/build')
      build(opts)
        .then((results) => {
          logger.log('done building...')
          if (!watch) process.exit(0)
        })
        .catch((err) => {
          logger.error(err)
          if (!watch) process.exit(1)
        })
    }
  })

commander
  .command('commit')
  .description('Force intelligent commit messages.')
  .action(function () {
    util.popMastarmFromArgv()
    const path = require('path')
    const bootstrap = require('commitizen/dist/cli/git-cz').bootstrap
    bootstrap({
      cliPath: path.join(__dirname, '../node_modules/commitizen'),
      config: {
        path: 'cz-conventional-changelog'
      }
    })
  })

commander
  .command('deploy [entries...]')
  .description('Bundle & Deploy JavaScript & CSS')
  .option('--cloudfront', 'CloudFront Distribution ID to invalidate.')
  .option('--s3bucket', 'S3 Bucket to push to.')
  .action(function (entries, options) {
    const commit = require('this-commit')()
    const username = require('username')

    const build = require('../lib/build')
    const pkg = require('../lib/pkg')
    const createPushToS3 = require('../lib/push-to-s3')

    const url = pkg.repository.url.replace('.git', '')
    const tag = `<${url}/commit/${commit}|${pkg.name}@${commit.slice(0, 6)}>`
    const config = loadConfig(process.cwd(), commander.config, commander.env)
    const get = util.makeGetFn([options, commander, config.settings])

    if (config.env.SLACK_WEBHOOK && config.env.SLACK_WEBHOOK.length > 0) {
      logger.logToSlack({
        channel: config.env.SLACK_CHANNEL || '#devops',
        webhook: config.env.SLACK_WEBHOOK
      })
    }

    const files = util.parseEntries([...entries, ...(get('entries') || [])])
    util.assertEntriesExist(files)
    const sourceFiles = files.map((f) => f[0])
    const outfiles = [
      ...files.map((f) => f[1]),
      ...files.map((f) => `${f[1]}.map`)
    ]

    const env = get('env') || 'development'
    const minify = get('minify')
    const buildOpts = {
      config,
      env,
      files,
      minify
    }
    const cloudfront = get('cloudfront')
    const s3bucket = get('s3bucket')

    const pushToS3 = createPushToS3({
      cloudfront,
      s3bucket
    })

    logger.log(
`:construction: *deploying: ${tag} by <@${username.sync()}>*
:cloud: *cloudfront:* ${cloudfront}
:hash: *commit:* ${commit}
:seedling: *env:* ${env}
:compression: *minify:* ${minify}
:package: *s3bucket:* ${s3bucket}
:hammer_and_wrench: *building:* ${sourceFiles.join(', ')}`
    ).then(() =>
      build(buildOpts)
        .then(() =>
          logger.log(`:rocket: *uploading:* ${sourceFiles.length * 2} file(s)`))
        .then(() =>
          Promise.all(outfiles.map((outfile) =>
            readFile(outfile).then((body) =>
              pushToS3({body, outfile})))))
        .then(() =>
          logger.log(`:tada: :confetti_ball: :tada: *deploy ${tag} complete* :tada: :confetti_ball: :tada:`)
            .then(() => process.exit(0)))
        .catch((err) =>
          logger.log(`:rotating_light: *${tag} error deploying ${tag} ${err.message || err}*`)
            .then(() => process.exit(1))))
  })

commander
  .command('lint')
  .allowUnknownOption()
  .description('Lint JavaScript [& CSS coming soon!]')
  .action(function () {
    const eslint = require('eslint')
    const engine = require('standard-engine')
    // get lint out of there
    process.argv = process.argv.filter((arg) => arg !== 'lint')
    // Force verbose
    process.argv.push('--verbose')

    engine.cli({
      bugs: 'github.com/conveyal/mastarm/issues',
      cmd: 'mastarm lint',
      eslint,
      eslintConfig: {
        configFile: path.join(__dirname, '../lib/eslintrc.json')
      },
      homepage: 'github.com/conveyal/mastarm',
      tagline: 'never forget to floss...or lint!',
      version: require('../package.json').version
    })
  })

commander
  .command('lint-messages [paths...]')
  .description('Check that all messages used in source code are present in config. Pass in path to source file(s). Set the config with --config.')
  .action(function (paths) {
    const lintMessages = require('../lib/lint-messages').lint
    const config = loadConfig(process.cwd(), commander.config, commander.env)
    // default to linting lib
    const errors = lintMessages(paths.length > 0 ? paths : ['lib'], config.messages)

    if (errors.length > 0) {
      logger.error(`${errors.length} missing messages`)
      for (const [message, file, line] of errors) {
        logger.error(`${file} line ${line}: ${message} is not defined`)
      }

      process.exit(1)
    } else {
      logger.log('No missing messages found! ðŸ’ƒ')
    }
  })

commander
  .command('prepublish [entries...]')
  .description('Transpile JavaScript down to ES5 with Babel')
  .action(function (cliEntries, options) {
    const prepublish = require('../lib/prepublish')
    const config = loadConfig(process.cwd(), commander.config, commander.env)
    const get = util.makeGetFn([options, commander, config.settings])

    const outdir = get('outdir')
    const entries = util.parseEntries(cliEntries && cliEntries.length > 0
      ? cliEntries
      : get('entries') || [],
      outdir
    )

    prepublish({
      entries,
      env: get('env'),
      outdir
    })
  })

commander
  .command('test [patterns...]')
  .description('Run tests using Jest')
  .option('-u, --update-snapshots', 'Force update of snapshots. USE WITH CAUTION.')
  .option('--coverage', 'Run Jest with coverage reporting')
  .option('--coverage-paths <paths>', 'Extra paths to collect code coverage from')
  .option('--no-cache', 'Run Jest without cache (defaults to using cache)')
  .option('--run-in-band', 'Run all tests serially in the current process')
  .option('--setup-files <paths>', 'Setup files to run before each test')
  .option('--test-environment <env>', 'Jest test environment to use (Jest default is jsdom)')
  .option('--test-path-ignore-patterns <patterns>', 'File patterns to ignore when scanning for test files')
  .action(function (patterns, options) {
    const jest = require('jest')
    const config = loadConfig(process.cwd(), commander.config, commander.env)
    const get = util.makeGetFn([options, commander, config.settings])
    const jestUtils = require('../lib/jest')
    util.configureEnvironment({config, env: get('env')})
    jest.run(jestUtils.generateTestConfig(patterns, options))
  })

commander.parse(process.argv)

const readFile = (f) =>
  new Promise((resolve, reject) =>
    fs.readFile(f, (err, data) => err
      ? reject(err)
      : resolve(data)))
